# PostgreSQL 18 逻辑复制方案

## 一、方案概述

本方案基于 PostgreSQL 18 的逻辑复制功能，实现从主节点（Master 1、Master 2）向从节点（Slave）的实时数据复制。逻辑复制通过发布-订阅模型实现，允许选择性复制特定的表或数据行，相比物理复制具有更高的灵活性和可扩展性。

根据当前基础架构，Master 1 承载数据库 A、B、C 的读写操作，Master 2 承载数据库 D 的读写操作，Slave 节点作为统一的数据只读副本，用于报表查询、数据分析等只读场景。通过逻辑复制，可以实现主从节点的数据实时同步，同时保持主节点的写入性能和从节点的读取负载均衡能力。

## 二、环境准备

### 2.1 安装要求

确保所有节点安装 PostgreSQL 18 版本，逻辑复制功能在 PostgreSQL 10 及以上版本中得到正式支持，PostgreSQL 18 版本提供了更完善的冲突检测机制和性能优化。建议所有节点使用相同的 PostgreSQL 18.x 版本，以避免因版本差异导致的兼容性问题。安装过程中需要选择启用 contrib 模块，其中的 pglogical 扩展提供了更高级的复制功能，但标准逻辑复制功能已能满足大多数场景需求。

```bash
# 验证 PostgreSQL 版本
psql --version

# 应输出类似：
# psql (PostgreSQL) 18.x
```

### 2.2 网络配置

确保主节点与从节点之间的网络通信畅通，逻辑复制使用 TCP 协议进行数据传输，默认端口为 5432。需要在各节点的 pg_hba.conf 文件中配置相应的访问规则，允许复制用户从其他节点连接。以下配置示例允许指定 IP 地址范围的用户进行复制操作：

```bash
# 在 Master 1（10.20.217.86）和 Master 2（10.20.217.89）的 pg_hba.conf 中添加：
host    all	all    0.0.0.0/0    scram-sha-256

# 在 Slave（10.20.217.87）的 pg_hba.conf 中添加：
host    all	all    0.0.0.0/0    scram-sha-256
```

修改 pg_hba.conf 后需要重新加载配置：

```bash
# 重新加载 PostgreSQL 配置
psql -c "SELECT pg_reload_conf();"
```

### 2.3 创建复制用户

在所有主节点上创建专用的复制用户，该用户将用于建立复制连接和执行复制操作。建议为复制用户设置强密码，并限制其权限范围，仅授予必要的复制相关权限：

```sql
-- 在 Master 1 和 Master 2 上执行
-- 创建复制用户
CREATE ROLE replicator WITH REPLICATION LOGIN PASSWORD '********';

-- 授予必要的权限
GRANT USAGE ON SCHEMA public TO replicator;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO replicator;

-- 对于需要复制的特定表，授予 SELECT 权限
-- GRANT SELECT ON table_name TO replicator;
```

## 三、逻辑复制核心配置

### 3.1 发布配置（Master 节点）

在 Master 1 上为数据库 A、B、C 创建发布，在 Master 2 上为数据库 D 创建发布。发布定义了哪些表或数据将被复制到订阅端。PostgreSQL 逻辑复制支持表级复制，可以选择复制整个表或仅复制符合条件的行（使用 WHERE 子句实现行过滤）：

```sql
-- ==================== Master 1（10.20.217.86）配置 ====================
-- 连接到数据库 A
\c database_a

-- 创建发布，复制所有表
CREATE PUBLICATION pub_database_a FOR ALL TABLES;

-- 设置发布属性
ALTER PUBLICATION pub_database_a SET (publish = 'insert,update,delete');

-- 连接到数据库 B
\c database_b

CREATE PUBLICATION pub_database_b FOR ALL TABLES;
ALTER PUBLICATION pub_database_b SET (publish = 'insert,update,delete');

-- 连接到数据库 C
\c database_c

CREATE PUBLICATION pub_database_c FOR ALL TABLES;
ALTER PUBLICATION pub_database_c SET (publish = 'insert,update,delete');

-- ==================== Master 2（10.20.217.89）配置 ====================
-- 连接到数据库 D
\c database_d

CREATE PUBLICATION pub_database_d FOR ALL TABLES;
ALTER PUBLICATION pub_database_d SET (publish = 'insert,update,delete');

-- 查看发布列表
SELECT * FROM pg_publication;

-- 查看发布包含的表
SELECT * FROM pg_publication_tables;
```

### 3.2 发布的高级配置

对于复杂的复制需求，可以配置分区表的复制、同步方式选择以及冲突处理策略。PostgreSQL 18 增强了分区表的逻辑复制支持，可以实现分区表的部分复制或跨分区复制。以下是一些高级配置示例：

```sql
-- 创建带参数的发布
CREATE PUBLICATION pub_with_options
    FOR TABLE partitioned_table
    WITH (publish = 'insert,update', publish_via_partition_root = true);

-- 启用列复制（仅复制指定列）
CREATE PUBLICATION pub_columns
    FOR TABLE users (id, name, email, created_at);

-- 配置复制的同步方式
-- 异步复制（默认）：主节点提交事务后立即返回，不等待从节点确认
-- 同步复制：主节点等待从节点确认复制后才返回
ALTER PUBLICATION pub_database_a SET (flush = false);  -- 异步
-- ALTER PUBLICATION pub_database_a SET (flush = true);  -- 同步
```

### 3.3 订阅配置（Slave 节点）

在 Slave 节点上创建订阅，订阅主节点上的发布。每个数据库需要分别创建对应的订阅，订阅将自动同步发布中定义的所有表结构和数据。创建订阅时需要指定连接字符串、发布名称以及可选的复制槽名称：

```sql
-- ==================== Slave（10.20.217.87）配置 ====================
-- 连接到 database_a
\c database_a

-- 创建订阅，连接到 Master 1
CREATE SUBSCRIPTION sub_database_a
    CONNECTION 'host=10.20.217.86 port=15432 dbname=database_a user=replicator password=YourSecurePassword123!'
    PUBLICATION pub_database_a
    WITH (slot_name = 'sub_database_a_slot', copy_data = true);

-- 连接到 database_b
\c database_b

CREATE SUBSCRIPTION sub_database_b
    CONNECTION 'host=10.20.217.86 port=15432 dbname=database_b user=replicator password=YourSecurePassword123!'
    PUBLICATION pub_database_b
    WITH (slot_name = 'sub_database_b_slot', copy_data = true);

-- 连接到 database_c
\c database_c

CREATE SUBSCRIPTION sub_database_c
    CONNECTION 'host=10.20.217.86 port=15432 dbname=database_c user=replicator password=YourSecurePassword123!'
    PUBLICATION pub_database_c
    WITH (slot_name = 'sub_database_c_slot', copy_data = true);

-- 连接到 database_d
\c database_d

CREATE SUBSCRIPTION sub_database_d
    CONNECTION 'host=10.20.217.89 port=15432 dbname=database_d user=replicator password=YourSecurePassword123!'
    PUBLICATION pub_database_d
    WITH (slot_name = 'sub_database_d_slot', copy_data = true);

-- 查看订阅状态
SELECT * FROM pg_subscription;

-- 查看订阅的同步状态
SELECT subname, pid, sync_state, sent_lsn, write_lsn, flush_lsn, replay_lsn
FROM pg_stat_subscription;
```

### 3.4 订阅的高级配置

可以配置多个订阅的并行复制、启用或禁用自动复制、设置连接池参数等。以下是高级订阅配置示例：

```sql
-- 创建带有额外选项的订阅
CREATE SUBSCRIPTION sub_advanced
    CONNECTION 'host=10.20.217.86 port=15432 dbname=database_a user=replicator password=YourSecurePassword123! connect_timeout=30'
    PUBLICATION pub_database_a
    WITH (
        slot_name = 'sub_advanced_slot',
        copy_data = true,
        enabled = true,
        create_slot = true,
        drop_slot = false
    );

-- 禁用/启用订阅
ALTER SUBSCRIPTION sub_database_a DISABLE;
ALTER SUBSCRIPTION sub_database_a ENABLE;

-- 刷新订阅（当发布变更时使用）
ALTER SUBSCRIPTION sub_database_a REFRESH PUBLICATION;

-- 修改订阅的连接信息
ALTER SUBSCRIPTION sub_database_a CONNECTION
    'host=10.20.217.86 port=15432 dbname=database_a user=replicator password=NewPassword456!';
```

## 四、监控与维护

### 4.1 复制状态监控

定期监控复制状态是确保系统稳定运行的关键。PostgreSQL 提供了丰富的系统视图和函数用于监控逻辑复制，包括复制延迟检测、冲突识别、错误处理等功能。以下监控脚本可以帮助您实时掌握复制状态：

```sql
-- 查看所有订阅及其状态
SELECT
    s.oid AS subid,
    s.subname AS subscription_name,
    s.subenabled AS enabled,
    s.subconninfo AS connection_info,
    p.pubname AS publication_name,
    CASE s.subenabled
        WHEN 't' THEN '运行中'
        WHEN 'f' THEN '已禁用'
    END AS status
FROM pg_subscription s
LEFT JOIN pg_subscription ps ON s.oid = ps.subid
LEFT JOIN pg_publication p ON s.subpubset @> ARRAY[p.pubname]::name[]
ORDER BY s.subname;

-- 查看复制进程详细信息
SELECT
    subname AS 订阅名称,
    pid AS 进程ID,
    relation_id AS 复制关系ID,
    CASE sync_state
        WHEN 'w' THEN '正在同步'
        WHEN 'd' THEN '正在下载'
        WHEN 'r' THEN '正在复制'
        WHEN 's' THEN '已同步'
    END AS 同步状态,
    sent_lsn AS 发送位置,
    write_lsn AS 写入位置,
    flush_lsn AS 刷写位置,
    replay_lsn AS 重放位置,
    EXTRACT(EPOCH FROM (now() - last_msg_send_time)) AS 最后消息发送延迟秒
FROM pg_stat_subscription;

-- 查看复制槽状态
SELECT
    slot_name AS 槽名称,
    plugin AS 插件,
    slot_type AS 槽类型,
    database AS 数据库,
    xmin AS 事务ID下限,
    catalog_xmin AS 目录事务ID,
    restart_lsn AS 重启LSN,
    confirmed_flush_lsn AS 确认刷新LSN,
    slot_active AS 是否活跃
FROM pg_replication_slots;

-- 计算复制延迟（以字节和事务数计算）
SELECT
    subname AS 订阅名称,
    pg_size_pretty(sent_lsn - replay_lsn) AS 复制延迟大小,
    sent_lsn::text AS 发送LSN,
    replay_lsn::text AS 重放LSN
FROM pg_stat_subscription
WHERE sync_state = 'r';
```

### 4.2 冲突检测与处理

逻辑复制过程中可能出现数据冲突，常见冲突类型包括唯一键冲突、外键约束冲突和数据类型转换错误。PostgreSQL 18 提供了更完善的冲突检测机制，可以在冲突发生时自动记录到 pg_subscription_rel 表中：

```sql
-- 查看复制冲突信息
SELECT
    sr.subid,
    s.subname,
    sr.relid,
    c.relname AS table_name,
    sr.errcode AS 错误代码,
    sr.errmsg AS 错误消息,
    sr.sqlstate AS SQL状态,
    sr.detail AS 详细信息,
    sr.local_time AS 本地时间
FROM pg_subscription_rel sr
JOIN pg_class c ON sr.relid = c.oid
JOIN pg_subscription s ON sr.subid = s.oid;

-- 处理冲突的常见方法
-- 1. 跳过冲突事务（谨慎使用）
-- SELECT pg_replication_origin_advance('sub_database_a_slot', '0/0000000');

-- 2. 删除冲突的复制槽并重新创建
-- DROP SUBSCRIPTION sub_database_a;
-- DROP PUBLICATION pub_database_a;
-- -- 重新创建发布和订阅

-- 3. 手动同步数据后重新建立复制
-- 在从节点上删除冲突数据后重新同步
```

### 4.3 性能监控与优化

监控复制性能对于确保系统响应能力至关重要。以下查询可以帮助识别性能瓶颈和优化复制配置：

```sql
-- 查看复制相关统计信息
SELECT
    stat_name AS 统计名称,
    stat_value AS 统计值,
    stat_reset AS 重置时间
FROM pg_stat_subscription;

-- 监控表复制统计
SELECT
    c.relname AS 表名称,
    psr.subid AS 订阅ID,
    psr.relid AS 表ID,
    psr.subrelid AS 订阅表ID,
    CASE psr.subconninfo
        WHEN 't' THEN '已同步'
        WHEN 'f' THEN '未同步'
    END AS 同步状态
FROM pg_subscription_rel psr
JOIN pg_class c ON psr.relid = c.oid;

-- 查看 wal 发送统计
SELECT
    usename AS 用户名,
    application_name AS 应用名称,
    client_addr AS 客户端地址,
    state AS 连接状态,
    sent_lsn AS 发送LSN,
    write_lsn AS 写入LSN,
    flush_lsn AS 刷写LSN,
    replay_lsn AS 重放LSN,
    pg_size_pretty(pg_wal_lsn_diff(sent_lsn, replay_lsn)) AS 复制延迟
FROM pg_stat_replication;

-- 检查长事务（可能影响复制）
SELECT
    pid AS 进程ID,
    usename AS 用户名,
    state AS 状态,
    query AS 查询,
    xact_start AS 事务开始时间,
    query_start AS 查询开始时间,
    EXTRACT(EPOCH FROM (now() - xact_start)) AS 事务持续秒数
FROM pg_stat_activity
WHERE state != 'idle'
    AND xact_start IS NOT NULL
    AND usename != 'replicator'
ORDER BY xact_start;
```

## 五、故障处理与恢复

### 5.1 常见故障及解决方案

在实际运维过程中，可能会遇到各种复制故障。以下是常见故障的识别方法和处理步骤：

```sql
-- 故障1：订阅连接失败
-- 症状：pg_stat_subscription 中 sync_state 为 'f' 或连接超时
-- 检查：SELECT * FROM pg_subscription WHERE subenabled = 'f';
-- 解决：检查网络连接、用户名密码、防火墙设置

-- 故障2：复制槽不存在
-- 症状：错误信息 " replication slot does not exist"
-- 检查：SELECT * FROM pg_replication_slots WHERE slot_name LIKE 'sub_%';
-- 解决：重新创建订阅并指定 create_slot = true

-- 故障3：表结构不一致
-- 症状：复制错误 "structure of query does not match destination"
-- 检查：在主从节点比较表结构
-- \d+ table_name
-- 解决：同步表结构后刷新订阅
-- ALTER SUBSCRIPTION sub_database_a REFRESH PUBLICATION;

-- 故障4：唯一键冲突
-- 症状：复制错误 "duplicate key value violates unique constraint"
-- 解决：见冲突处理章节

-- 故障5：发布被删除
-- 症状：订阅状态异常，发布不存在
-- 解决：重新创建发布
-- CREATE PUBLICATION pub_database_a FOR ALL TABLES;
```

### 5.2 订阅重建流程

当订阅出现无法恢复的错误时，需要按照以下步骤重建订阅：

```sql
-- 步骤1：禁用并删除现有订阅
\c database_a
ALTER SUBSCRIPTION sub_database_a DISABLE;
DROP SUBSCRIPTION sub_database_a;

-- 步骤2：删除复制槽（在主节点执行）
-- 连接到 Master 1
-- SELECT pg_drop_replication_slot('sub_database_a_slot');

-- 步骤3：验证订阅已删除
SELECT * FROM pg_subscription WHERE subname = 'sub_database_a';

-- 步骤4：重新创建订阅
CREATE SUBSCRIPTION sub_database_a
    CONNECTION 'host=10.20.217.86 port=5432 dbname=database_a user=replicator password=YourSecurePassword123!'
    PUBLICATION pub_database_a
    WITH (slot_name = 'sub_database_a_slot', copy_data = true);

-- 步骤5：验证订阅状态
SELECT * FROM pg_subscription;
SELECT * FROM pg_stat_subscription;
```

### 5.3 数据同步验证

定期验证主从数据一致性是确保复制正确性的重要措施。以下脚本可以用于数据一致性检查：

```sql
-- 在 Slave 节点执行
-- 检查表记录数是否一致
SELECT
    'database_a' AS database_name,
    c.relname AS table_name,
    pg_total_relation_size(c.oid) AS table_size,
    (SELECT COUNT(*) FROM database_ainformation_schema.tables t WHERE t.table_schema = 'public') AS table_count
FROM pg_class c
JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE c.relkind = 'r' AND n.nspname = 'public'
AND EXISTS (
    SELECT 1 FROM pg_subscription_rel psr
    JOIN pg_publication_table ppt ON psr.relid = c.oid
    WHERE psr.subrelid = c.oid
);

-- 手动触发一致性检查
-- CREATE PUBLICATION test_pub FOR TABLE target_table WITH (publish = 'nothing');
-- ALTER SUBSCRIPTION test_sub REFRESH PUBLICATION WITH (copy_data = false);

-- 对比主从表数据（示例：users 表）
-- Master 1 上：
-- SELECT COUNT(*) FROM users; -- 假设返回 10000

-- Slave 上：
-- SELECT COUNT(*) FROM users; -- 应该返回相同数量
```

## 六、配置参数优化

### 6.1 postgresql.conf 参数调整

合理配置 PostgreSQL 参数可以显著提升复制性能和稳定性。以下是建议的参数配置：

```bash
# 在 Master 节点（10.20.217.86 和 10.20.217.89）的 postgresql.conf 中添加或修改：

# 复制相关配置
wal_level = logical              # 必须设置为 logical 以支持逻辑复制
max_replication_slots = 10       # 根据订阅数量调整，建议大于订阅数
max_wal_senders = 10             # 根据从节点数量调整
max_logical_replication_workers = 4  # 逻辑复制工作进程数
max_sync_workers_per_subscription = 2  # 每个订阅的同步进程数

# 性能优化配置
shared_buffers = '8GB'           # 建议为系统内存的 1/4
effective_cache_size = '24GB'    # 建议为系统内存的 3/4
work_mem = '256MB'               # 根据查询复杂度调整
maintenance_work_mem = '2GB'     # 维护操作内存
wal_buffers = '64MB'             # WAL 缓冲区
checkpoint_completion_target = 0.9

# 连接配置
max_connections = 200            # 根据应用需求调整

# 日志配置
log_min_duration_statement = 1000  # 记录超过 1 秒的查询
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d '
log_lock_waits = on
log_replication_commands = on
```

修改后重新加载配置：

```sql
-- 重新加载配置（不中断服务）
SELECT pg_reload_conf();

-- 或重启 PostgreSQL 服务
-- systemctl restart postgresql
```

### 6.2 复制性能调优

根据实际负载情况，可以调整以下参数优化复制性能：

```sql
-- 查看当前复制配置
SHOW wal_level;
SHOW max_replication_slots;
SHOW max_logical_replication_workers;
SHOW max_sync_workers_per_subscription;

-- 动态调整参数（需要超级用户权限）
ALTER SYSTEM SET max_logical_replication_workers = 8;
SELECT pg_reload_conf();

-- 调整订阅的复制槽保留策略
-- 在主节点的 postgresql.conf 中：
# logical_decoding_work_mem = '64MB'  # 逻辑解码内存
# max_slot_wal_keep_size = '1GB'     # 复制槽保留的 WAL 大小
```

## 七、高可用与容灾

### 7.1 故障转移配置

对于生产环境，建议配置自动故障转移机制，确保主节点故障时可以从节点快速接管。以下是基于 Patroni 的高可用配置概述：

```bash
# Patroni 配置示例（config.yaml）
scope: postgres-cluster
namespace: /service/
name: master1

restapi:
  listen: 0.0.0.0:8008
  connect_address: 10.20.217.86:8008
  authentication:
    username: admin
    password: admin_password

etcd:
  host: 10.20.217.87:2379

bootstrap:
  dcs:
    ttl: 30
    loop_wait: 10
    retry_timeout: 10
    maximum_lag_on_failover: 1048576
    postgresql:
      use_pg_rewind: true
      use_slots: true
      parameters:
        wal_level: logical
        max_replication_slots: 10
        max_wal_senders: 10

postgresql:
  listen: 0.0.0.0:5432
  connect_address: 10.20.217.86:5432
  data_dir: /var/lib/postgresql/18/main
  bin_dir: /usr/lib/postgresql/18/bin
  authentication:
    superuser:
      username: postgres
      password: superuser_password
    replication:
      username: replicator
      password: replicator_password
  parameters:
    unix_socket_directories: '/var/run/postgresql'
```

### 7.2 订阅的 HA 配置

在 Slave 节点配置多个主节点的订阅可以实现更高级别的高可用：

```sql
-- 为关键数据库配置多个订阅源
-- 当主节点故障时，可以切换到备用主节点

-- 创建到备用 Master 3 的订阅
CREATE SUBSCRIPTION sub_database_a_standby
    CONNECTION 'host=10.20.217.90 port=5432 dbname=database_a user=replicator password=YourSecurePassword123!'
    PUBLICATION pub_database_a
    WITH (slot_name = 'sub_database_a_standby', copy_data = false, enabled = false);

-- 故障切换脚本示例
-- 1. 禁用主订阅
-- ALTER SUBSCRIPTION sub_database_a DISABLE;
-- ALTER SUBSCRIPTION sub_database_a_standby ENABLE;
-- ALTER SUBSCRIPTION sub_database_a_standby REFRESH PUBLICATION;
```

## 八、备份与恢复

### 8.1 发布端备份策略

在逻辑复制环境中，备份策略需要同时考虑主节点和从节点的数据安全：

```bash
# 使用 pg_basebackup 进行物理备份
pg_basebackup -h 10.20.217.86 -U postgres -D /backup/base -Ft -z -P

# 使用 pg_dump 进行逻辑备份
pg_dump -h 10.20.217.86 -U postgres -Fc database_a > database_a_$(date +%Y%m%d).dump

# 定期备份复制槽状态
psql -c "SELECT * FROM pg_replication_slots;" > /backup/replication_slots_$(date +%Y%m%d).sql
```

### 8.2 恢复流程

当需要从备份恢复数据时，应按照以下步骤操作：

```bash
# 1. 停止应用写入
# 2. 在主节点备份当前复制状态
psql -c "SELECT * FROM pg_replication_slots;" > /backup/slots_backup.sql

# 3. 恢复数据库
pg_restore -h 10.20.217.86 -U postgres -d database_a /backup/database_a.dump

# 4. 重新建立复制
psql -c "ALTER SUBSCRIPTION sub_database_a REFRESH PUBLICATION;"

# 5. 验证数据完整性
psql -c "SELECT count(*) FROM users;"
```

## 九、总结

本方案基于 PostgreSQL 18 的逻辑复制功能，实现了从 Master 1（数据库 A、B、C）和 Master 2（数据库 D）向 Slave 节点的实时数据复制。逻辑复制提供了以下优势：

- **灵活的数据复制**：可以选择性复制特定表或特定行，减少不必要的数据传输
- ** Schema 变更支持**：逻辑复制支持在复制过程中进行表结构变更
- **异构平台复制**：可以从 Linux 主节点复制到 Windows 从节点（或反之）
- **冲突检测**：自动检测和处理数据冲突，确保数据一致性

建议在生产环境中部署监控告警系统，实时监控复制状态和延迟，确保及时发现和处理故障。同时，定期进行故障演练，验证恢复流程的有效性。

## 附录：常用排查 SQL 指令

### 1. 复制状态综合检查

```sql
-- 一、基础状态检查（发现问题第一步）
-- 检查所有订阅状态
SELECT
    subname AS 订阅名称,
    subenabled AS 是否启用,
    subconninfo AS 连接信息,
    CASE
        WHEN subenabled = 't' THEN '运行正常'
        WHEN subenabled = 'f' THEN '已禁用'
        ELSE '异常'
    END AS 状态说明
FROM pg_subscription
ORDER BY subname;

-- 检查订阅进程状态
SELECT
    subname AS 订阅名称,
    pid AS 进程ID,
    relid AS 关系ID,
    sync_state AS 同步状态,
    sent_lsn AS 发送位置,
    write_lsn AS 写入位置,
    flush_lsn AS 刷写位置,
    replay_lsn AS 重放位置,
    last_msg_send_time AS 最后发送时间,
    last_msg_receipt_time AS 最后接收时间,
    latest_end_lsn AS 最新结束LSN,
    latest_end_time AS 最新结束时间
FROM pg_stat_subscription
ORDER BY subname;

-- 二、详细状态检查（定位具体问题）
-- 查看复制槽详细信息
SELECT
    slot_name AS 槽名称,
    plugin AS 插件,
    slot_type AS 槽类型,
    database AS 数据库名,
    xmin AS 事务下限,
    catalog_xmin AS 目录事务下限,
    restart_lsn AS 重启LSN,
    confirmed_flush_lsn AS 确认刷写LSN,
    slot_active AS 是否活跃,
    temporary AS 是否临时,
    dummy_catalog AS 是否虚拟目录
FROM pg_replication_slots
ORDER BY slot_name;

-- 查看发布详细信息
SELECT
    p.oid AS 发布ID,
    p.pubname AS 发布名称,
    p.pubowner AS 所有者,
    p.puballtables AS 是否所有表,
    p.pubinsert AS 是否复制INSERT,
    p.pubupdate AS 是否复制UPDATE,
    p.pubdelete AS 是否复制DELETE,
    p.pubtruncate AS 是否复制TRUNCATE,
    p.pubviaroot AS 是否通过根表发布,
    pg_get_userbyid(p.pubowner) AS 所有者用户名
FROM pg_publication p
ORDER BY p.pubname;

-- 查看发布包含的表
SELECT
    pub.pubname AS 发布名称,
    rel.relname AS 表名,
    nsp.nspname AS 模式名,
    att.attname AS 列名
FROM pg_publication pub
JOIN pg_publication_table pubtab ON pub.oid = pubtab.pubid
JOIN pg_class rel ON pubtab.relid = rel.oid
JOIN pg_namespace nsp ON rel.relnamespace = nsp.oid
LEFT JOIN pg_publication_columns pubcol ON pub.oid = pubcol.pubid AND rel.oid = pubcol.relid
LEFT JOIN pg_attribute att ON pubcol.attnum = att.attnum AND rel.oid = att.attrelid
ORDER BY pub.pubname, rel.relname;

-- 查看订阅表同步状态
SELECT
    s.subname AS 订阅名称,
    c.relname AS 表名,
    n.nspname AS 模式名,
    sr.subrelid AS 订阅表ID,
    sr.relid AS 源表ID,
    sr.errcode AS 错误代码,
    sr.errmsg AS 错误消息,
    CASE sr.subconninfo
        WHEN 't' THEN '同步正常'
        WHEN 'f' THEN '同步异常'
        ELSE '未知'
    END AS 同步状态
FROM pg_subscription_rel sr
JOIN pg_class c ON sr.relid = c.oid
JOIN pg_namespace n ON c.relnamespace = n.oid
JOIN pg_subscription s ON sr.subid = s.oid
ORDER BY s.subname, c.relname;
```

### 2. 复制延迟监控

```sql
-- 一、实时延迟检查
-- 计算复制延迟（以字节为单位）
SELECT
    subname AS 订阅名称,
    pid AS 工作进程ID,
    sync_state AS 同步状态,
    sent_lsn::text AS 发送LSN,
    write_lsn::text AS 写入LSN,
    flush_lsn::text AS 刷写LSN,
    replay_lsn::text AS 重放LSN,
    pg_wal_lsn_diff(sent_lsn, replay_lsn) AS 延迟字节数,
    pg_size_pretty(pg_wal_lsn_diff(sent_lsn, replay_lsn)) AS 延迟大小,
    pg_wal_lsn_diff(flush_lsn, replay_lsn) AS 应用延迟字节
FROM pg_stat_subscription
WHERE sync_state = 'r'
ORDER BY pg_wal_lsn_diff(sent_lsn, replay_lsn) DESC;

-- 二、延迟趋势分析
-- 查看各订阅的延迟历史（基于统计信息）
SELECT
    subname AS 订阅名称,
    stat_name AS 统计项,
    stat_value AS 统计值,
    stat_reset AS 重置时间
FROM pg_stat_subscription
WHERE stat_name IN ('apply_delay', 'apply_lag', 'sync_latency')
ORDER BY subname, stat_name;

-- 三、长时间延迟检测
-- 检查是否有订阅延迟超过阈值（超过 100MB）
SELECT
    subname AS 订阅名称,
    pg_size_pretty(pg_wal_lsn_diff(sent_lsn, replay_lsn)) AS 当前延迟,
    sent_lsn::text AS 发送位置,
    replay_lsn::text AS 重放位置,
    last_msg_send_time AS 最后发送时间,
    EXTRACT(EPOCH FROM (now() - last_msg_send_time)) AS 发送延迟秒
FROM pg_stat_subscription
WHERE pg_wal_lsn_diff(sent_lsn, replay_lsn) > 100 * 1024 * 1024
ORDER BY pg_wal_lsn_diff(sent_lsn, replay_lsn) DESC;

-- 四、延迟告警查询
SELECT
    subname AS 订阅名称,
    CASE
        WHEN pg_wal_lsn_diff(sent_lsn, replay_lsn) > 1024 * 1024 * 1024 THEN '严重延迟'
        WHEN pg_wal_lsn_diff(sent_lsn, replay_lsn) > 100 * 1024 * 1024 THEN '高延迟'
        WHEN pg_wal_lsn_diff(sent_lsn, replay_lsn) > 10 * 1024 * 1024 THEN '中延迟'
        ELSE '正常'
    END AS 延迟级别,
    pg_size_pretty(pg_wal_lsn_diff(sent_lsn, replay_lsn)) AS 延迟大小,
    sync_state AS 同步状态
FROM pg_stat_subscription
ORDER BY pg_wal_lsn_diff(sent_lsn, replay_lsn) DESC;
```

### 3. 连接与权限排查

```sql
-- 一、连接状态检查
-- 查看活跃的复制连接
SELECT
    usename AS 用户名,
    application_name AS 应用名称,
    client_addr AS 客户端地址,
    client_hostname AS 客户端主机名,
    client_port AS 客户端端口,
    backend_start AS 连接开始时间,
    state AS 连接状态,
    sent_lsn AS 发送LSN,
    write_lsn AS 写入LSN,
    replay_lsn AS 重放LSN,
    pg_wal_lsn_diff(sent_lsn, replay_lsn) AS 复制延迟,
    wait_event_type AS 等待事件类型,
    wait_event AS 等待事件,
    query AS 当前查询
FROM pg_stat_replication
ORDER BY backend_start;

-- 二、用户权限检查
-- 检查复制用户的权限
SELECT
    rolname AS 用户名,
    rolsuper AS 是否超级用户,
    rolcreaterole AS 是否可创建角色,
    rolcreatedb AS 是否可创建数据库,
    rolreplication AS 是否可复制,
    rolcanlogin AS 是否可登录,
    rolconnlimit AS 连接限制
FROM pg_roles
WHERE rolname = 'replicator';

-- 检查复制用户的表权限
SELECT
    grantee AS 授权用户,
    table_schema AS 模式名,
    table_name AS 表名,
    privilege_type AS 权限类型,
    is_grantable AS 是否可再授权
FROM information_schema.table_privileges
WHERE grantee = 'replicator'
ORDER BY table_schema, table_name, privilege_type;

-- 三、连接测试
-- 测试从节点能否连接到主节点（在从节点执行）
-- 返回连接成功或失败信息
SELECT
    '测试连接' AS 测试类型,
    current_setting('listen_addresses') AS 监听地址,
    current_setting('port') AS 端口,
    version() AS 版本信息;

-- 四、认证排查
-- 检查 pg_hba.conf 配置是否生效
SELECT
    type AS 连接类型,
    database AS 数据库,
    user AS 用户,
    address AS 地址,
    auth_method AS 认证方法,
    options AS 选项
FROM pg_hba_file_rules
WHERE database IN ('replication', 'all', 'database_a', 'database_b', 'database_c', 'database_d')
    AND user IN ('replicator', 'all')
ORDER BY type, database, user;
```

### 4. 冲突检测与处理

```sql
-- 一、冲突信息查询
-- 查看所有复制冲突
SELECT
    s.subname AS 订阅名称,
    c.relname AS 冲突表名,
    n.nspname AS 模式名,
    sr.errcode AS 错误代码,
    sr.sqlstate AS SQL状态,
    sr.errmsg AS 错误消息,
    sr.detail AS 详细信息,
    sr.hint AS 提示信息,
    sr.local_time AS 本地冲突时间,
    sr.remote_lsn AS 远端LSN
FROM pg_subscription_rel sr
JOIN pg_class c ON sr.relid = c.oid
JOIN pg_namespace n ON c.relnamespace = n.oid
JOIN pg_subscription s ON sr.subid = s.oid
WHERE sr.errcode IS NOT NULL
ORDER BY sr.local_time DESC;

-- 二、冲突类型统计
SELECT
    s.subname AS 订阅名称,
    sr.errcode AS 错误代码,
    COUNT(*) AS 冲突次数,
    sr.errmsg AS 错误消息
FROM pg_subscription_rel sr
JOIN pg_subscription s ON sr.subid = s.oid
WHERE sr.errcode IS NOT NULL
GROUP BY s.subname, sr.errcode, sr.errmsg
ORDER BY COUNT(*) DESC;

-- 三、唯一键冲突排查
-- 查找冲突表中的重复数据
-- 需要在冲突的表上执行
-- SELECT * FROM 冲突的表名 WHERE ctid IN (SELECT unnest(invalid_ctids) FROM pg_subscription_rel WHERE relid = '冲突表的OID'::regclass);

-- 四、跳过冲突的事务
-- 注意：此操作可能导致数据不一致，仅在确认可以跳过时使用
-- SELECT pg_replication_origin_advance('订阅槽名称', '新的LSN位置');
-- 例如：跳过当前冲突
-- SELECT pg_replication_origin_advance('sub_database_a_slot', sent_lsn::text)
-- FROM pg_stat_subscription WHERE subname = 'sub_database_a';

-- 五、冲突解决建议
SELECT
    sr.errcode AS 错误代码,
    CASE sr.errcode
        WHEN '23505' THEN '唯一键冲突 - 检查重复数据或使用 pg_replication_origin_advance 跳过'
        WHEN '23503' THEN '外键冲突 - 检查引用完整性'
        WHEN '23502' THEN '非空约束冲突 - 检查必填字段'
        WHEN '42804' THEN '数据类型不匹配 - 检查表结构一致性'
        ELSE '其他冲突 - 查看详细信息'
    END AS 解决建议,
    sr.errmsg AS 错误消息,
    sr.detail AS 详细信息
FROM pg_subscription_rel sr
WHERE sr.errcode IS NOT NULL
GROUP BY sr.errcode, sr.errmsg, sr.detail;
```

### 5. 数据一致性验证

```sql
-- 一、表结构一致性检查
-- 对比主从节点表结构
-- 在主节点执行，获取表结构
SELECT
    c.relname AS 表名,
    a.attname AS 列名,
    a.atttypid::regtype AS 数据类型,
    a.attlen AS 长度,
    a.attnotnull AS 是否非空,
    a.atthasdef AS 是否有默认值,
    adef.adsrc AS 默认值
FROM pg_class c
JOIN pg_namespace n ON n.oid = c.relnamespace
JOIN pg_attribute a ON a.attrelid = c.oid
LEFT JOIN pg_attrdef adef ON adef.adrelid = a.attrelid AND adef.adnum = a.attnum
WHERE n.nspname = 'public'
    AND a.attnum > 0
    AND c.relkind = 'r'
ORDER BY c.relname, a.attnum;

-- 二、数据行数对比
-- 获取主节点各表行数（在主节点执行）
SELECT
    n.nspname AS 模式名,
    c.relname AS 表名,
    c.reltuples AS 估计行数,
    pg_total_relation_size(c.oid) AS 表总大小,
    pg_relation_size(c.oid) AS 表大小
FROM pg_class c
JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE n.nspname = 'public'
    AND c.relkind = 'r'
    AND EXISTS (
        SELECT 1 FROM pg_publication_table pt
        JOIN pg_publication p ON pt.pubid = p.oid
        WHERE pt.relid = c.oid AND p.puballtables = true
    )
ORDER BY c.reltuples DESC;

-- 三、数据校验和检查
-- 对比主从节点特定表的数据
-- 在主节点执行
SELECT
    'database_a' AS 数据库名,
    'users' AS 表名,
    COUNT(*) AS 主节点行数,
    (SELECT COUNT(*) FROM database_a.public.users) AS 对比行数,
    CASE
        WHEN COUNT(*) = (SELECT COUNT(*) FROM database_a.public.users) THEN '一致'
        ELSE '不一致'
    END AS 校验结果
FROM database_a.public.users;

-- 四、分区表复制检查
-- 检查分区表是否正确复制
SELECT
    p.pubname AS 发布名称,
    pc.relname AS 分区根表,
    pp.relname AS 分区子表,
    pp.relkind AS 表类型,
    CASE pp.relkind
        WHEN 'r' THEN '普通表'
        WHEN 'p' THEN '分区父表'
        WHEN 'c' THEN '分区子表'
        ELSE '其他'
    END AS 表类型说明
FROM pg_publication_table pt
JOIN pg_class pc ON pt.relid = pc.oid
LEFT JOIN pg_inherits i ON i.inhparent = pc.oid
LEFT JOIN pg_class pp ON i.inhrelid = pp.oid
JOIN pg_publication p ON pt.pubid = p.oid
WHERE p.pubname LIKE 'pub_%'
ORDER BY p.pubname, pc.relname;
```

### 6. 性能问题排查

```sql
-- 一、长时间运行的事务检查
-- 可能影响复制的事务
SELECT
    pid AS 进程ID,
    usename AS 用户名,
    application_name AS 应用名称,
    state AS 状态,
    query AS 查询,
    wait_event_type AS 等待类型,
    wait_event AS 等待事件,
    xact_start AS 事务开始时间,
    query_start AS 查询开始时间,
    EXTRACT(EPOCH FROM (now() - xact_start)) AS 事务持续秒,
    EXTRACT(EPOCH FROM (now() - query_start)) AS 查询持续秒
FROM pg_stat_activity
WHERE state != 'idle'
    AND xact_start IS NOT NULL
    AND pid NOT IN (SELECT pid FROM pg_stat_subscription)
ORDER BY xact_start;

-- 二、WAL 生成速率监控
SELECT
    pg_current_wal_lsn() AS 当前LSN,
    pg_wal_lsn_diff(pg_current_wal_lsn(), '0/0') AS LSN位置,
    (SELECT COUNT(*) FROM pg_ls_waldir() ORDER BY modification DESC LIMIT 1) AS WAL文件数;

-- 三、复制工作进程状态
SELECT
    pid AS 进程ID,
    usename AS 用户名,
    application_name AS 应用名称,
    state AS 状态,
    query AS 查询,
    wait_event_type AS 等待类型,
    wait_event AS 等待事件,
    backend_start AS 开始时间,
    EXTRACT(EPOCH FROM (now() - backend_start)) AS 运行秒数
FROM pg_stat_activity
WHERE application_name LIKE 'logical replication worker%'
ORDER BY backend_start;

-- 四、锁等待排查
-- 检查复制相关的锁等待
SELECT
    blocked_locks.pid AS 等待进程ID,
    blocked_activity.usename AS 等待用户,
    blocked_activity.query AS 等待查询,
    blocked_activity.state AS 等待状态,
    blocked_activity.wait_event AS 等待事件,
    blocking_locks.pid AS 阻塞进程ID,
    blocking_activity.usename AS 阻塞用户,
    blocking_activity.query AS 阻塞查询,
    blocking_activity.state AS 阻塞状态
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_locks.pid = blocked_activity.pid
JOIN pg_catalog.pg_locks blocking_locks ON blocked_locks.locktype = blocking_locks.locktype
    AND blocked_locks.database IS NOT DISTINCT FROM blocking_locks.database
    AND blocked_locks.relation IS NOT DISTINCT FROM blocking_locks.relation
JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_locks.pid = blocking_activity.pid
WHERE NOT blocked_locks.granted
    AND (blocking_activity.application_name LIKE 'logical%' OR blocked_activity.application_name LIKE 'logical%');

-- 五、I/O 性能检查
SELECT
    relname AS 表名,
    heap_blks_read AS 读取块数,
    heap_blks_hit AS 缓存命中,
    heap_blks_hit::decimal / NULLIF(heap_blks_read + heap_blks_hit, 0) * 100 AS 缓存命中率,
    idx_blks_read AS 索引读取,
    idx_blks_hit AS 索引命中,
    idx_blks_hit::decimal / NULLIF(idx_blks_read + idx_blks_hit, 0) * 100 AS 索引命中率
FROM pg_statio_user_tables
ORDER BY heap_blks_read DESC
LIMIT 20;
```

### 7. 日志与错误排查

```sql
-- 一、查看 PostgreSQL 日志配置
SHOW data_directory;
SHOW log_directory;
SHOW log_filename;
SHOW log_statement;
SHOW log_min_messages;
SHOW log_error_verbosity;

-- 二、检查最近的复制相关日志
-- 需要查看 PostgreSQL 日志文件
-- 常用日志文件位置：/var/log/postgresql/postgresql-18-main.log 或 /pgdata/log/

-- 三、查看数据库错误日志（在数据库中）
SELECT
    now() AS 查询时间,
    current_setting('log_min_messages') AS 日志级别,
    current_setting('log_error_verbosity') AS 错误详细度;

-- 四、复制相关的配置参数
SELECT
    name AS 参数名,
    setting AS 当前值,
    unit AS 单位,
    short_desc AS 说明,
    enumvals AS 可选值
FROM pg_settings
WHERE name IN (
    'wal_level',
    'max_replication_slots',
    'max_wal_senders',
    'max_logical_replication_workers',
    'max_sync_workers_per_subscription',
    'logical_decoding_work_mem',
    'max_slot_wal_keep_size'
)
ORDER BY name;

-- 五、监控告警设置建议
SELECT
    '复制延迟告警' AS 告警类型,
    '建议延迟超过 100MB 时触发告警' AS 告警阈值,
    '建议延迟超过 1GB 时触发严重告警' AS 严重阈值,
    '建议配置 Prometheus Alertmanager 或 Nagios' AS 推荐工具;

SELECT
    '订阅状态告警' AS 告警类型,
    '订阅禁用或连接断开时触发告警' AS 告警条件,
    '建议每 30 秒检查一次订阅状态' AS 检查频率;

SELECT
    '复制槽活跃度告警' AS 告警类型,
    '复制槽不活跃超过 5 分钟时触发告警' AS 告警条件;
```

### 8. 快速排查流程

```sql
-- 问题 1：复制不工作
-- 按顺序执行以下检查
-- 步骤 1：检查订阅是否启用
SELECT subname, subenabled FROM pg_subscription WHERE subname LIKE 'sub_%';

-- 步骤 2：检查复制进程是否运行
SELECT * FROM pg_stat_subscription WHERE subname LIKE 'sub_%';

-- 步骤 3：检查复制槽是否活跃
SELECT slot_name, slot_active, database FROM pg_replication_slots WHERE slot_name LIKE 'sub_%';

-- 步骤 4：检查错误信息
SELECT sr.subname, sr.relid, c.relname, sr.errcode, sr.errmsg
FROM pg_subscription_rel sr
JOIN pg_class c ON sr.relid = c.oid
WHERE sr.errcode IS NOT NULL;

-- 步骤 5：检查网络连接
SELECT usename, application_name, client_addr, state FROM pg_stat_replication;

-- 问题 2：复制延迟过大
-- 检查当前延迟
SELECT subname, pg_size_pretty(pg_wal_lsn_diff(sent_lsn, replay_lsn)) AS lag
FROM pg_stat_subscription;

-- 检查是否有长时间运行的事务
SELECT pid, usename, xact_start, query FROM pg_stat_activity
WHERE xact_start IS NOT NULL AND state != 'idle'
ORDER BY xact_start LIMIT 5;

-- 检查系统资源使用情况
-- 需要在操作系统层面检查：CPU、内存、磁盘 I/O、网络

-- 问题 3：复制槽报错
-- 检查复制槽状态
SELECT slot_name, restart_lsn, confirmed_flush_lsn,
       pg_wal_lsn_diff(restart_lsn, confirmed_flush_lsn) AS 槽滞后
FROM pg_replication_slots;

-- 检查 WAL 保留
SELECT name, setting, unit FROM pg_settings WHERE name = 'max_slot_wal_keep_size';

-- 问题 4：发布变更后复制异常
-- 刷新订阅以同步变更
ALTER SUBSCRIPTION sub_database_a REFRESH PUBLICATION;

-- 检查发布表是否包含所有需要的表
SELECT pubname, relname FROM pg_publication_tables WHERE pubname LIKE 'pub_%';
```

### 9. 日常巡检脚本

```sql
-- 综合巡检报告
SELECT '===== PostgreSQL 逻辑复制巡检报告 =====' AS 报告标题;
SELECT '巡检时间: ' || now() AS 巡检时间;

-- 1. 订阅状态汇总
SELECT '===== 订阅状态 =====' AS 章节;
SELECT
    subname AS 订阅名称,
    CASE subenabled
        WHEN 't' THEN '正常'
        WHEN 'f' THEN '禁用'
        ELSE '异常'
    END AS 启用状态,
    CASE
        WHEN pid IS NOT NULL THEN '运行中'
        ELSE '停止'
    END AS 进程状态,
    CASE
        WHEN sync_state = 's' THEN '已同步'
        WHEN sync_state = 'r' THEN '复制中'
        WHEN sync_state = 'w' THEN '同步中'
        WHEN sync_state = 'd' THEN '下载中'
        ELSE '未知'
    END AS 同步状态,
    pg_size_pretty(pg_wal_lsn_diff(sent_lsn, replay_lsn)) AS 复制延迟
FROM pg_stat_subscription
ORDER BY subname;

-- 2. 复制槽状态
SELECT '===== 复制槽状态 =====' AS 章节;
SELECT
    slot_name AS 槽名称,
    database AS 数据库,
    slot_active AS 是否活跃,
    pg_size_pretty(pg_wal_lsn_diff(restart_lsn, confirmed_flush_lsn)) AS 槽滞后
FROM pg_replication_slots
ORDER BY slot_name;

-- 3. 发布状态
SELECT '===== 发布状态 =====' AS 章节;
SELECT
    pubname AS 发布名称,
    puballtables AS 所有表,
    pubinsert AS INSERT,
    pubupdate AS UPDATE,
    pubdelete AS DELETE,
    pubtruncate AS TRUNCATE
FROM pg_publication
ORDER BY pubname;

-- 4. 冲突统计
SELECT '===== 冲突统计 =====' AS 章节;
SELECT
    s.subname AS 订阅名称,
    COUNT(sr.relid) AS 冲突表数
FROM pg_subscription_rel sr
JOIN pg_subscription s ON sr.subid = s.oid
WHERE sr.errcode IS NOT NULL
GROUP BY s.subname
ORDER BY s.subname;

-- 5. 性能指标
SELECT '===== 性能指标 =====' AS 章节;
SELECT
    '最大复制槽数' AS 指标名称,
    setting AS 当前值
FROM pg_settings WHERE name = 'max_replication_slots'
UNION ALL
SELECT
    '最大 WAL 发送进程数',
    setting
FROM pg_settings WHERE name = 'max_wal_senders'
UNION ALL
SELECT
    '逻辑复制工作进程数',
    setting
FROM pg_settings WHERE name = 'max_logical_replication_workers'
UNION ALL
SELECT
    '每个订阅同步进程数',
    setting
FROM pg_settings WHERE name = 'max_sync_workers_per_subscription';

SELECT '===== 巡检完成 =====' AS 报告结束;
```

以上排查命令涵盖了逻辑复制的日常运维场景，建议将常用命令保存为脚本或视图，便于快速排查问题。
